# 연관관계 매핑 기초
## 5.1 단방향 연관관계
연관관계 중에서 다대일(N:1) 단방향 관계를 가장먼저 이해해야한다.

ex) 회원과 팀의 관계에서 회원은 하나의 팀에만 소속될 수 있다.(N:1)

* 객체 연관관계 : 회원 객체는 Memeber.team 필드로 팀 객체와 연관관계를 맺는다. 회원 객체와 팀 객체는 단방향 관계로 Member는 필드를 통하여 팀을 알 수 있지만 반대로 팀은 회원을 알 수 없다.
* 테이블 연관관계 : 회원 테이블을 TEAM_ID 외래키로 팀 테이블과 연관관계를 맺는다. 회원 테이블과 팀 테이블은 양방향 관계로 외래키를 통하여 회원과 팀을 조인할 수 있고 반대로 팀과 회원을 조인할 수 있다.

참조를 통한 연관관계는 언제나 단방향이다. 객체간에 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야 하는데 이것은 양방향관계라기 보단 서로 다른 단방향 관계 2개이다. 반면 테이블은 외래 키 하나로 양방향으로 조인할 수 있다.

__객체 관계 매핑__ : JPA를 사용한 매핑

    @Entity
    public class Member {

        @Id
        @Column(name="MEMBER_ID")
        private String id;

        private String username;

        //연관관계 매핑
        @ManyToOne                      //N:1관계 매핑정보
        @JoinColumn(name="TEAM_ID")     //외래 키를 매핑할 때 사용(생략가능)
        private Team team;

        //연관관계 설정
        public void setTeam(Team team) {
            this.team = team;
        }

        //Getter, Setter..
    }

    @Entity
    public class Team{

        @Id
        @Column(name="TEAM_ID")
        private String id;

        private String name;

        //Getter, Setter...
    }

__@JoinColumn__
* name : 매핑할 외래 키 이름
* referencedColumnName : 외래 키가 참조하는 대상 테이블의 컬럼명
* foreignKey(DDL) : 외래 키 제약조건 직접 지정, 테이블 생성시에만 사용

__@ManyToOne__
* optional : 기본값 true, false로 설정시 연관된 엔티티가 항상 있어야 함
* fetch : 글로벌 페치 전략 설정
* cascade : 영속석 전이 기능을 사용
* targetEntity : 연관된 엔티티의 타입 정보 설정(거의 사용하지 않음)

## 5.2 연관관계 사용
1)저장 :

    //팀1 저장
    Team team1 = new Team("team1", "팀1");
    em.persist(team1);

    //회원1 저장
    Member member1 = new Member("member1", "회원1");
    member1.setTeam(team1);     //연관관계 설정 member1 -> team1
    em.persist(member1);

    //회원2 저장
    Member member2 = new Member("member2", "회원2");
    member2.setTeam(team1);     //연관관계 설정 member2 -> team1
    em.persist(member2);

2)조회 : 연관관계가 있는 엔티티 조회 방법은
* 객체 그래프 탐색 : member.getTeam()을 사용하여 member와 연관된 team 엔티티를 조회할 수 있다. 이처럼 객체를 통해 연관된 엔티티를 조회하는 것을 객체 그래프 탐색이라 한다.
* 객체지향 쿼리 사용 : JPQL

    String jpql = "select m from Member m join m.team t where t.name=:teamName";

    List< Member > resultList = em.createQuery(jpql, Member.class).setPrameter("teamName", "팀1").getResultList();

3)수정 : 수정은 단순히 불러온 엔티티의 값만 변경해두면 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동한다.

4)연관관계 제거 : member1.setTeam(null); null로 설정하여 연관관계가 제거된다.

5)연관된 엔티티 삭제 : 연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야한다. 그렇지 않으면 외래 키 제약조건으로 인해 오류가 발생한다.  member1.setTeam(null); em.remove();

## 5.3 양방향 연관관계
팀에서 회원으로 연관관계를 설정하게 되면 회원과 팀은 N:1관계인데 팀과 회원은 1:N관계가 된다. 일대다 관계는 여러 건과 연관관계를 맺을 수 있으므로 컬렉션을 사용해야 한다.

    @Entity
    public class Member {

        @Id
        @Column(name="MEMBER_ID")
        private String id;

        private String username;

        @ManyToOne
        @JoinColumn(name="TEAM_ID")
        private Team team;

        //연관관계 설정
        public void setTeam(Team team) {
            this.team = team;
        }

        //Getter, Setter..
    }

    @Entity
    public class Team{

        @Id
        @Column(name="TEAM_ID")
        private String id;

        private String name;

        @OneToMany(mappedBy="team")     //mappedBy 속성은 양방향 매핑일 때 사용 반대쪽 매핑의 필드 이름을 사용하면 된다.
        private List<Member> members = new ArrayList<Member>();

        //Getter, Setter...
    }

    public void biDirection() {

        Team team = em.find(Team.class, "team1");
        List<Member> members = team.getMembers();

        for(Member member: members) {
            System.out.println(member.getUsername());
        }
    }