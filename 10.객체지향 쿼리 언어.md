# 10. 객체지향 쿼리 언어
## 10.1 객체지향 쿼리 소개
EntityManager.find() 메소드를 사용하면 식별자로 엔티티 하나를 조회할 수 있다. 복잡한 검색을 하려는 경우 필요한 경우 SQL로 내용을 걸러서 조회를 해야하는데 ORM을 사용하면 엔티티 객체를 대상으로 개발하므로 검색도 테이블이 아닌 엔티티 객체를 대상으로 하는 방법이 필요하다.

JPQL은 이러한 문제를 해결하기 위해 만들어 졌다. JPQL은 엔티티 객체를 대상으로 하는 객체지향 쿼리고 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.

JPA는 JPQL뿐만 아니라 다양한 검색 방법을 지원한다.
* JPQL
* Criteria 쿼리 : JQPL을 편리하게 작성하도록 도와주는 API, 빌더 클래스 모음
* 네이티브 SQL : JPA에서 JPQL 대신 직접 SQL 사용
* QueryDSL : JPQL을 편리하게 작성하도록 도와주는 API, 빌더 클래스 모음
* JDBC 직접사용

### 10.1.1 JPQL
엔티티 객체를 조회하는 객체지향 쿼리이고, 특정 데이터베이스에 의존하지 않는다. 또 JPQL이 제공하는 표준화된 함수를 사용하면 선택한 방언에 따라 해당 데이터베이스에 맞춘 적절한 SQL 함수가 실행된다. SQL보다 간결함

    @Entity(name="Member")
    public class Member {
        @Column(name="name")
        private String username;
        ...
    }
    
    //JPQL
    String jpql = "select m from Member as m where m.username = 'kim'";
    List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();

예제에서 Member는 엔티티 이름, m.username은 테이블 컬럼명이 아니라 `엔티티 객체의 필드명`이다.

### 10.1.2 Criteria 쿼리
Criteria는 문자가 아닌 `query.select(m).where(...)`처럼 프로그래밍 코드로 JPQL을 작성할 수 있다.

Criteria의 장점
* 컴파일 시점에 오류를 발견할 수 있다.
* IDE를 사용하면 코드 자동완성을 지원한다.
* 동적 쿼리를 작성하기 편하다.
```
//Criteria 사용준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

//루트 클래스(조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

//쿼리 생성
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
```
m.get("username")을 보면 필드명을 문자로 작성했다. 이 부분도 코드로 작성하고 싶으면 `메타 모델`을 사용하면 된다.

__메타 모델__ : 어노테이션 프로세서 기능을 사용하여 Member 엔티티 클래스로부터 Member_라는 Criteria 전용 클래스를 생성하는 것
```
//메타모델 사용 전
m.get("username");

//메타모델 사용 후
m.get(Member_.username)
```
Criteria는 장점이 많지만 장점을 상쇄할 정도로 복잡하고, 장황하다. 또 사용하기 불편하고 가독성이 떨어진다는 단점이 있다.

### 10.1.3 QueryDSL
QueryDSL은 코드 기반이면서 단순하고 사용하기 쉽다. JPA 표준은 아니고 오픈소스 프로젝트여서 JPA뿐만 아니라 다른 것에서도 거의 같은 문법으로 지원한다.
```
//준비
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

//쿼리, 결과 조회
List<Member> members = query.from(member.username.eq("kim").list(member);
```
QueryDSL도 어노테이션 프로세서를 사용해서 쿼리 전용 클래스를 만들어야 한다. QMember는 Member 엔티티 클래스를 기반으로 생성한 QueryDSL 쿼리 전용 클래스다.

### 10.1.4 네이티브 SQL 소개
JPA에서 SQL을 직접 사용할 수 있는 기능을 지원하는데 이를 네이티브 SQL이라 한다. JPQL을 사용해도 특정 데이터베이스에 의존하는 기능을 사용해야하는 경우가 있는데 이때 사용하면 된다.
```
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList = em.createNativeQuery(sql, Member.class).getResultList();
```

### 10.1.5 JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크 사용
JPA는 JDBC 커넥션을 획득하는 API를 제공하지 않으므로 JPA 구현체가 제공하는 방법을 사용해야 한다.
```
Session session = entityManager.unwrap(Session.class);
session.doWork(new Work() {

    @Ovrride
    public void execute(Connection connection) throws SQLException {
        //work...
    }
});
```
JDBC를 직접 사용하든 마이바티스 같은 SQL 매퍼와 사용하든 JPA를 우회해서 데이터베이스에 접근하기 때문에 JPA가 인식하지 못한다. 이로인해 영속성 컨텍스트와 데이터베이스가 불일치 상태가 되어 데이터 무결성을 훼손할 수 있다. 이러한 이슈를 해결하기 위해서 __SQL 실행 직전에 영속성 컨텍스트를 수동으로 플러시해서 데이터베이스와 영속성 컨텍스트를 동기화하면 된다.__