# 값 타입
## 9.1 기본값 타입
    @Entity
    public class Member {
        @Id @GerneratedValue
        private Long id;
        private String name;
        private int age;
    }

String, int 등이 기본 값 타입이다. 식별자 값도 없고, 생명주기도 엔티티에 의존한다. 그리고 값 타입은 공유하면 안 된다.


## 9.2 임베디드 타입(복합 값 타입)
    @Entity
    public class Mamber {
        @Id @GerneratedValue
        private Long id;
        private String name;
        private int age;

        @Embeded 
        Period workPeriod;
        @Embeded 
        Address homeAddress;
    }

    @Embeddable
    public class Period {
        @Temporal(TemporalType.DATE)
        Date startDatel

        @Temporal(TemporalType.DATE)
        Date endDatel

        ...

        public boolean isWork(Date date) { ... }
    }

    @Embeddable
    public class Address {
        @Column(name="city")
        private String city;
        private String street;
        private String zipcode;
        ...
    }

임베디드 타입 속성
* @Embeddable : 값 타입을 정의하는 곳에 표시
* @Embedded : 값 타입을 사용하는 곳에 표시

**임베디드 타입은 기본 생성자가 필수

__@AttributeOverride__ : 임베디드 타입에 정의한 매핑정보를 재정의하려면 엔티티에 @AttributeOverride를 사용하면 된다.

    @Entity
    public class Mamber {
        @Id @GerneratedValue
        private Long id;
        private String name;
        private int age;

        @Embeded 
        Address homeAddress;

        @Embeded 
        @AttributeOverrides({
            @AttributeOverride(name="city", column=@Column(name="COMPANY_CITY")),
            @AttributeOverride(name="street", column=@Column(name="COMPANY_STREET")),
            @AttributeOverride(name="zipcode", column=@Column(name="COMPANY_ZIPCODE"))
            })
            Address companyAddress;
    }

@AttributeOverrides는 엔티티에 설정해야 한다. (임베디드 타입이 임베디드 타입을 가지고 있어도), 임베디드 타입이 null이면 매핑한 컬럼 값은 모두 null이 된다.

## 9.3 값 타입과 불변 객체
    member1.setHomeAddress(new Address("OldCity"));
    Address address = member1.getHomeAddress();

    address.setCity("NewCity");     //member1의 address 값을 공유해서 사용
    member.setHomeAddress(address);

회원2에 새로운 주소를 할당하려고 회원1의 주소를  그대로 참조해서 사용해서 회원1의 주소 값도 변경되어 버렸다. 이처럼 값 타입을 여러 엔티티에서 공유하면 위험하다.  이런 문제를 막으려면 값을 복사해서 사용하면 된다.

    member1.setHomeAddress(new Address("OldCity"));
    Address address = member1.getHomeAddress();

    Address newAddress = address.clone();
    newAddress.setCity("NewCity")
    member2.setHomeAddress(newAddress);

객체의 공유 참조는 피할 수 없다. 가장 단순한 해결법으로는 객체의 값을 수정하지 못하게 막으면 된다. 따라서 값 타입은 될 수 있으면 불변 객체로 설계해야 한다. (생성자로만 값을 설정하고 수정자를 만들지 않으면 됨 setter X)